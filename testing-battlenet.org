# (setq org-export-allow-bind-keywords t)
#+BIND: org-latex-title-command "\\author[Ben Deane]{\\href{mailto:bdeane@blizzard.com}{Ben Deane} \\\\ {\\scriptsize{Principal Engineer, \\href{http://www.blizzard.com/}{Blizzard Entertainment}}} \\\\ {\\footnotesize{\\texttt{\\href{mailto:bdeane@blizzard.com}{bdeane@blizzard.com}, \\href{http://www.twitter.com/ben_deane}{@ben_deane}}}}}\n\\maketitle"

#+TITLE: Testing Battle.net
#+BEAMER_HEADER: \subtitle{(Before deploying to millions of players)}
#+DATE: 13th May 2015
#+AUTHOR: Ben Deane

#+DESCRIPTION: C++-oriented solutions to testing Battle.net before deployment
#+KEYWORDS: battle.net testing c++
#+LANGUAGE:  en
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t author:nil
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:
#+LaTeX_CLASS: beamer
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+LaTeX_HEADER: \usepackage{helvet}
#+LaTeX_HEADER: \usepackage{color}
#+LaTeX_HEADER: \usepackage{anyfontsize}
#+LaTeX_HEADER: \usepackage{amsmath, amsthm, amssymb, breqn}
#+BEAMER_THEME: Madrid
#+BEAMER_COLOR_THEME: wolverine
#+STARTUP: beamer
#+BEAMER_FRAME_LEVEL: 2

# To generate notes pages only:
# +LaTeX_CLASS_OPTIONS: [handout]
# +LaTeX_HEADER: \setbeameroption{show only notes}
# +LaTeX_HEADER: \usepackage{pgfpages}
# +LaTeX_HEADER: \pgfpagesuselayout{2 on 1}[letterpaper,border shrink=5mm]

# For normal presentation output:
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LaTeX_HEADER: \setbeamertemplate{navigation symbols}{}%remove navigation symbols

# syntax highlighting colors
#+LaTeX_HEADER: \definecolor{sh_comment}{RGB}{64,128,128}
#+LaTeX_HEADER: \definecolor{sh_hilight}{RGB}{255,231,0}
#+LaTeX_HEADER: \newcommand{\reducedstrut}{\vrule width 0pt height .9\ht\strutbox depth .9\dp\strutbox\relax}
#+LaTeX_HEADER: \newcommand{\hilight}[1]{\begingroup\setlength{\fboxsep}{0pt}\colorbox{sh_hilight}{\reducedstrut#1\/}\endgroup}

* A bit about Battle.net
** Battle.net infrastructure
- About 325,000 lines of C++
  - Servers + client libraries
- "Battle.net Game Service"
  - Authenticate players
  - Social: friends, presence
  - Matchmaking (cooperative/competitive)
  - Achievements/profiles

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Explain what battle.net does.
- Game service vs Battle.net umbrella.
- Define terms.

** Battle.net is highly...
- Distributed
- Asynchronous
- Configured
- Architecture-varied
  - inheritance
  - composition
  - value-oriented

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Many machines connected.
- Almost everything asynchronous, callback-driven.
- Lots of configuration read at startup time from git repo.
- Code is pretty good, but size => faults occur.

** A familiar situation
- No practice at unit testing
- Large project with many moving parts
- Mature lower level libraries
- New code (features) added at an alarming rate

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- A familiar situation for me and my colleagues.
- Game industry is not accustomed to unit testing.

** What's typically well-tested?
- UTF-8 string conversion
- String interpolation
- URL parsing/decomposition
- Stats/math code

\begin{center}
\leavevmode\\[1\baselineskip]
These things are "easy mode" for tests.
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Usually well-tested.
- Not worth thinking about edge cases - can use off-the-shelf tests (eg UTF-8).

** Not-so-well tested?
- Matchmaking algorithms
- Queueing/Load balancing algorithms
- Other high-dependency, asynchronous, "large" code

\begin{center}
\leavevmode\\[1\baselineskip]
These things are harder to test. Where to start?
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- This is what I started to think about.
- I read Kent Beck and Bob Martin. I watched Misko Hevery.
- Conclusion: we aren't practised at testing.
- Need to practise - use TDD
- Extend unit testing framework as I go

** No magic bullet
- I wrote a lot of mocks
- Set up a lot of data structures for test
- A lot of testing code to keep bug-free
- But along the way I found
  - better code structure
  - useful techniques

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- My journey.
- Things were messy for a while. (They even shipped messy.)
- But I found some useful things to share.

* Testing legacy code
** Monolithic classes
\begin{center}
Problem 1: Getting started testing huge legacy classes.\\[2\baselineskip]
(What idiot wrote this code? \footnotesize{Oh, it was me, 3 months ago...})
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- in a codebase this size, there are some classes that get large
- and they do complex things
- and we need to test them

** Exhibit A: hard to test

*** block                                                       :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{\hilight{class ChannelBase :\ public rpc::Implementor<protocol::channel::Channel>;}\\
\hilight{class ChannelImpl :\ public ChannelBase;}\\[1\baselineskip]
\hilight{class PresenceChannelImpl :\ public ChannelImpl}\\
\string{\\
public:\\
\ \ PresenceChannelImpl(\\
\ \ \ \ Process* process,\\
\ \ \ \ rpc::RPCDispatcher* insideDispatcher,\\
\ \ \ \ const EntityId\& entityId,\\
\ \ \ \ ChannelDelegate* channelDelegate,\\
\ \ \ \ ChannelOwner* owner,\\
\ \ \ \ const PresenceFieldConfigMap\& fieldMap);\\
\string};}
\end{scriptsize}

*** block                                                       :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{class ChannelBase :\ public rpc::Implementor<protocol::channel::Channel>;\\
class ChannelImpl :\ public ChannelBase;\\[1\baselineskip]
class PresenceChannelImpl :\ public ChannelImpl\\
\string{\\
public:\\
\ \ PresenceChannelImpl(\\
\ \ \ \ Process* process,\\
\ \ \ \ \hilight{rpc::RPCDispatcher* insideDispatcher,}\\
\ \ \ \ const EntityId\& entityId,\\
\ \ \ \ ChannelDelegate* channelDelegate,\\
\ \ \ \ ChannelOwner* owner,\\
\ \ \ \ const PresenceFieldConfigMap\& fieldMap);\\
\string};}
\end{scriptsize}

*** block                                                       :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{class ChannelBase :\ public rpc::Implementor<protocol::channel::Channel>;\\
class ChannelImpl :\ public ChannelBase;\\[1\baselineskip]
class PresenceChannelImpl :\ public ChannelImpl\\
\string{\\
public:\\
\ \ PresenceChannelImpl(\\
\ \ \ \ Process* process,\\
\ \ \ \ rpc::RPCDispatcher* insideDispatcher,\\
\ \ \ \ const EntityId\& entityId,\\
\ \ \ \ \hilight{ChannelDelegate* channelDelegate,}\\
\ \ \ \ ChannelOwner* owner,\\
\ \ \ \ \hilight{const PresenceFieldConfigMap\& fieldMap});\\
\string};}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Explain types.
- Deep inheritance that mixes concerns.
  1. What is RPC doing in there?
  1. And protocol dependency.
  1. "Traditional" interface-impl hierarchy.
- Constructor takes 6 args.
  1. Some constructor args have a wide interface.
  1. Again RPC.
  1. Lots of configuration.
  1. These things are onerous to mock.

** Exhibit B: hard to test

*** block                                                       :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{\hilight{class AchievementsServiceImpl}\\
\ \ \hilight{:\ public bnet::achievements::AchievementsService}\\
\ \ \hilight{,\ public AchievementsServiceStaticDataLoader}\\
\string{\\
public:\\
\ \ AchievementsServiceImpl(\\
\ \ \ \ bnet::internal::ServerHelper\& serverHelper,\\
\ \ \ \ mysql::Databases* mysql);\\
\string};}
\end{scriptsize}

*** block                                                       :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{class AchievementsServiceImpl\\
\ \ :\ public bnet::achievements::AchievementsService\\
\ \ ,\ public AchievementsServiceStaticDataLoader\\
\string{\\
public:\\
\ \ AchievementsServiceImpl(\\
\ \ \ \ \hilight{bnet::internal::ServerHelper\& serverHelper,}\\
\ \ \ \ \hilight{mysql::Databases* mysql});\\
\string};}
\end{scriptsize}

*** block                                                       :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{class ServerHelper\\
\string{\\
public:\\
\ \ ServerHelper(...); // 12 args!\\[1\baselineskip]
\ \ rpc::RPCServer* GetInsideRPCServer() const;\\
\ \ rpc::RPCServer* GetOutsideRPCServer() const;\\
\ \ ...\\
\string};\\[2\baselineskip]}
\end{scriptsize}
\begin{center}
In hindsight, this was a mistake...
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Achievements actually quite well-tested
- Again the pattern of deriving from protocol
- Static data loader => IO going on in constructor?
- Some DI going on (database interface)
- Constructor args have wide interfaces
- ServerHelper legitimized the pattern of coupling IO/RPC and functionality

** Patterns inimical to testing
- Lack of dependency injection
- Doing work in constructors (cf RAII)
- Wide interfaces (especially when passed to constructors)

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Everyone tells us that dependency injection is required for testing
- But it's not enough
- RAII is bad: testable things shouldn't own resources
- Wide interfaces to construction are bad

** Class structure for testing
*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
- Base class (contains logic)
- Derived class (contains I/O, config, etc)
#+begin_center
[[./diag1.pdf]]
#+end_center

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
- Component class (contains logic)
- Entity/Object class (contains I/O, config, etc)
#+begin_center
[[./diag2.pdf]]
#+end_center

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Instead of "traditional" interface-impl split
- Use the split of logic vs interactions
  - Logic in base
  - Interactions in derived
  - Derived has as few dependencies as possible
  - Ruthlessly inject dependencies
- Good news: this is quite easy to apply

** Example: Queueing for games
#+begin_center
[[./diag3.pdf]]
#+end_center

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Explain queueing for games.
- Manage multiple queues.
- Server capacity, link capacity. KR/TW problem.
- Rate limiting even in the presence of adequate server capacity.

** Queueing for games
*** block                                                 :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameQueueBase} contains the queueing logic\\[1\baselineskip]
\hrule
\end{center}

*** GameQueueBase                                               :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{\hilight{class GameQueueBase}\\
\string{\\
public:\\
\ \ GameQueueBase(\\
\ \ \ \ shared_ptr<ServerPoolInterface> interface,\\
\ \ \ \ const PopCallback\& popCb,\\
\ \ \ \ const UpdateCallback\& updateCb,\\
\ \ \ \ const PollTimerCallback\& pollTimerCb,\\
\ \ \ \ const NotificationTimerCallback\& notificationTimerCb);\\[1\baselineskip]
\ \ bool\ \ \ Push(...);\\
\ \ size_t Pop(...);\\
\ \ void\ \ \ Remove(...);\\
\ \ size_t PollQueue(...);\\[1\baselineskip]
\ \ ...\\
\string};\\}
\end{scriptsize}

*** GameQueueBase                                               :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{class GameQueueBase\\
\string{\\
public:\\
\ \ \hilight{GameQueueBase(}\\
\ \ \ \ \hilight{shared_ptr<ServerPoolInterface> interface,}\\
\ \ \ \ \hilight{const PopCallback\& popCb,}\\
\ \ \ \ \hilight{const UpdateCallback\& updateCb,}\\
\ \ \ \ \hilight{const PollTimerCallback\& pollTimerCb,}\\
\ \ \ \ \hilight{const NotificationTimerCallback\& notificationTimerCb);}\\[1\baselineskip]
\ \ bool\ \ \ Push(...);\\
\ \ size_t Pop(...);\\
\ \ void\ \ \ Remove(...);\\
\ \ size_t PollQueue(...);\\[1\baselineskip]
\ \ ...\\
\string};\\}
\end{scriptsize}

*** GameQueueBase                                               :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{class GameQueueBase\\
\string{\\
public:\\
\ \ GameQueueBase(\\
\ \ \ \ shared_ptr<ServerPoolInterface> interface,\\
\ \ \ \ const PopCallback\& popCb,\\
\ \ \ \ const UpdateCallback\& updateCb,\\
\ \ \ \ const PollTimerCallback\& pollTimerCb,\\
\ \ \ \ const NotificationTimerCallback\& notificationTimerCb);\\[1\baselineskip]
\ \ \hilight{bool\ \ \ Push(...);}\\
\ \ \hilight{size_t Pop(...);}\\
\ \ \hilight{void\ \ \ Remove(...);}\\
\ \ \hilight{size_t PollQueue(...);}\\[1\baselineskip]
\ \ ...\\
\string};\\}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Moderately complex queueing logic all in the base.
- Logic in standalone class: no RPC inheritance.
- Constructor args have narrow interfaces.
  - callbacks (1-function interface)
  - server pool: a couple of functions for server capacity information
- Interface not cluttered with other concerns: just queueing stuff.

** Queueing for games
*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
**** block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameQueueImpl} deals with protocols\\[1\baselineskip]
\hrule
\end{center}

**** GameQueueImpl                                       :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{scriptsize}
\texttt{\hilight{class GameQueueImpl}\\
\ \ \hilight{:\ public GameQueueBase}\\
\ \ \hilight{,\ public protocol::game_queue::GameQueue}\\
\string{\\
public:\\
\ \ {\color{sh_comment}\textit{// protocol handler functions}}\\
\ \ virtual void AddToQueue(...);\\
\ \ virtual void RemoveFromQueue(...);\\
\ \ ...\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// system events}}\\
\ \ bool OnInit(...);\\
\ \ bool OnFlush(...);\\
\ \ void OnShutdown(...);\\
\ \ void OnPeerDisconnected(...);\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
**** block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameQueueImpl} deals with protocols\\[1\baselineskip]
\hrule
\end{center}

**** GameQueueImpl                                       :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{scriptsize}
\texttt{class GameQueueImpl\\
\ \ :\ public GameQueueBase\\
\ \ ,\ public protocol::game_queue::GameQueue\\
\string{\\
public:\\
\ \ {\color{sh_comment}\textit{// protocol handler functions}}\\
\ \ \hilight{virtual void AddToQueue(...);}\\
\ \ \hilight{virtual void RemoveFromQueue(...);}\\
\ \ ...\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// system events}}\\
\ \ bool OnInit(...);\\
\ \ bool OnFlush(...);\\
\ \ void OnShutdown(...);\\
\ \ void OnPeerDisconnected(...);\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
**** block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameQueueImpl} deals with system events\\[1\baselineskip]
\hrule
\end{center}

**** GameQueueImpl                                       :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{scriptsize}
\texttt{class GameQueueImpl\\
\ \ :\ public GameQueueBase\\
\ \ ,\ public protocol::game_queue::GameQueue\\
\string{\\
public:\\
\ \ {\color{sh_comment}\textit{// protocol handler functions}}\\
\ \ virtual void AddToQueue(...);\\
\ \ virtual void RemoveFromQueue(...);\\
\ \ ...\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// system events}}\\
\ \ \hilight{bool OnInit(...);}\\
\ \ \hilight{bool OnFlush(...);}\\
\ \ \hilight{void OnShutdown(...);}\\
\ \ \hilight{void OnPeerDisconnected(...);}\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <4>
:END:
**** block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameQueueImpl} deals with config\\[1\baselineskip]
\hrule
\end{center}

**** GameQueueImpl                                       :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{scriptsize}
\texttt{class GameQueueImpl\\
\ \ :\ public GameQueueBase\\
\ \ ,\ public protocol::game_queue::GameQueue\\
\string{\\
public:\\
\ \ ...\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// setup/config}}\\
\ \ \hilight{bool ProcessProgramConfig(...);}\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// queue polling}}\\
\ \ void StartPollTimer(...);\\
\ \ void ServicePollTimer(...);\\
\ \ void StartNotificationPollTimer(...);\\
\ \ void ServiceNotificationPollTimer(...);\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <5>
:END:
**** block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameQueueImpl} deals with polling logic\\[1\baselineskip]
\hrule
\end{center}

**** GameQueueImpl                                       :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{scriptsize}
\texttt{class GameQueueImpl\\
\ \ :\ public GameQueueBase\\
\ \ ,\ public protocol::game_queue::GameQueue\\
\string{\\
public:\\
\ \ ...\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// setup/config}}\\
\ \ bool ProcessProgramConfig(...);\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// queue polling}}\\
\ \ \hilight{void StartPollTimer(...);}\\
\ \ \hilight{void ServicePollTimer(...);}\\
\ \ \hilight{void StartNotificationPollTimer(...);}\\
\ \ \hilight{void ServiceNotificationPollTimer(...);}\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Derive impl from base, using the logic-interaction divide
- Derived class implements
  - rpc calls
  - config
  - interaction with system
- Some of this stays at the level of the impl
- Some is dependency-injected to control the logic
  - keep base testable with as little setup as poss

** Example: Matchmaking
#+begin_center
[[./diag4.pdf]]
#+end_center

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Explain matchmaking
  - composition-based
  - game factory segments player base by difficulty, act, hardcore/non
  - deals with arbitrary groups of players
  - lots of telemetry
  - matching by attributes
- game factory implements matchmaking strategy

** Matchmaking

*** block                                                 :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameFactory} contains matchmaking logic\\[1\baselineskip]
\hrule
\end{center}

*** GameFactory                                                 :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{class GameFactory\\
\string{\\
public:\\
\ \ \hilight{GameFactory(const AttributeValue\& version,}\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \hilight{const ProgramId\& programId,}\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \hilight{GameFactoryId id);}\\[1\baselineskip]
\ \ virtual bool Configure(const GameFactoryConfig\& config);\\[1\baselineskip]
\ \ ...\\
\ \ virtual Error RegisterPlayers(...);\\
\ \ virtual bool UnregisterPlayers(...);\\
\ \ virtual Error JoinGame(...);\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** GameFactory                                                 :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{class GameFactory\\
\string{\\
public:\\
\ \ GameFactory(const AttributeValue\& version,\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ const ProgramId\& programId,\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ GameFactoryId id);\\[1\baselineskip]
\ \ \hilight{virtual bool Configure(const GameFactoryConfig\& config);}\\[1\baselineskip]
\ \ ...\\
\ \ virtual Error RegisterPlayers(...);\\
\ \ virtual bool UnregisterPlayers(...);\\
\ \ virtual Error JoinGame(...);\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** GameFactory                                                 :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{class GameFactory\\
\string{\\
public:\\
\ \ GameFactory(const AttributeValue\& version,\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ const ProgramId\& programId,\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ GameFactoryId id);\\[1\baselineskip]
\ \ virtual bool Configure(const GameFactoryConfig\& config);\\[1\baselineskip]
\ \ ...\\
\ \ \hilight{virtual Error RegisterPlayers(...);}\\
\ \ \hilight{virtual bool UnregisterPlayers(...);}\\
\ \ \hilight{virtual Error JoinGame(...);}\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Small constructor interface
- Configuration required, but deferred => default config will be testable
  - Constructor leaves object initialised properly
- Just the MM logic in factory

** Matchmaking
*** block                                                 :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\texttt{GameMasterImpl} deals with interactions\\[1\baselineskip]
\hrule
\end{center}

*** GameMasterImpl                                              :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{class GameMasterImpl\\
\ \ :\ public protocol::game_master::GameMaster\\
\string{\\
public:\\
\ \ ...\\
\ \ \hilight{void OnPeerDisconnected(...);}\\
\ \ ...\\
\ \ void InstantiateFactories(...);\\
\ \ ...\\
\ \ virtual void ListFactories(...);\\
\ \ virtual void JoinGame(...);\\
\ \ virtual void FindGame(...);\\
\ \ virtual void GameEnded(...);\\
\ \ virtual void PlayerLeft(...);\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** GameMasterImpl                                              :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{class GameMasterImpl\\
\ \ :\ public protocol::game_master::GameMaster\\
\string{\\
public:\\
\ \ ...\\
\ \ void OnPeerDisconnected(...);\\
\ \ ...\\
\ \ \hilight{void InstantiateFactories(...);}\\
\ \ ...\\
\ \ virtual void ListFactories(...);\\
\ \ virtual void JoinGame(...);\\
\ \ virtual void FindGame(...);\\
\ \ virtual void GameEnded(...);\\
\ \ virtual void PlayerLeft(...);\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** GameMasterImpl                                              :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{class GameMasterImpl\\
\ \ :\ public protocol::game_master::GameMaster\\
\string{\\
public:\\
\ \ ...\\
\ \ void OnPeerDisconnected(...);\\
\ \ ...\\
\ \ void InstantiateFactories(...);\\
\ \ ...\\
\ \ \hilight{virtual void ListFactories(...);}\\
\ \ \hilight{virtual void JoinGame(...);}\\
\ \ \hilight{virtual void FindGame(...);}\\
\ \ \hilight{virtual void GameEnded(...);}\\
\ \ \hilight{virtual void PlayerLeft(...);}\\
\ \ ...\\
\string};\\}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- system events
- config injection
- rpc interface

** A successful pattern
- Decouple logic from other concerns
  - Dependency injection for config etc
  - Makes the logic testable
- This can be fairly easily applied even to monolithic classes
  - Just apply the inheritance pattern
  - Some testing beats no testing

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Side effect: not bad for optimization
  - layout: logic members at start of class
- If you have monolithic classes, you can start splitting logic out as a base class
  - you get _something_ testable
  - once you have something testable, you can build on it
  - tested code is easier to refactor even if it starts out ugly

** Testable classes
\begin{center}
Dependency injection is probably the biggest factor affecting whether or not code \emph{is testable at all}.\\[2\baselineskip]
Even with DI, classes are \emph{onerous to test} unless constructors take few arguments, using narrow interfaces.
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- A practical guideline

* Testing scalability (I)
** Testing for scalability
\begin{center}
Problem 2: Confidence in my code's ability to scale.\\[2\baselineskip]
(I don't want a 3am call from devops.)
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- The code has to work when a million players come along

** Testing Performance/Efficiency
- Different solutions for
  - thousands (performance)
  - millions (performance + algorithms)
  - billions (algorithms by construction)
- Battle.net's working sets are in the millions
  - e.g. matchmaking

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- data set in the thousands =>
  - performance is king (cache effects etc)
  - algorithms not really important
- billions =>
  - usually highly distributed (can't run on dev machine)
  - use abstract algebra to achieve correct-by-construction algorithms
- millions =>
  - can run on a single machine
  - performance is important (caching)
  - but algorithms are also important
  - can run on dev machines but without scalable data sets

** Problems in million-land
- Computations can run on a single machine
- Data structures are important to performance
  - Caching concerns, optimizations can get you 100x
  - But they can't get you 100,000x
- Algorithms are important to efficiency

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Perf only gets you so far
- You need algorithms to avoid blowup at scale

** Testing for performance
- Timed tests are easy, not so useful
- My machine is a Windows desktop
- Production machine is a CentOS blade
- Timed tests
  - compare times when optimizing
  - can't tell me if code is fast enough in an absolute sense

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Of course I can time tests
- This can give me some gross idea of optimizations
- It's still hard to do things properly (my desktop isn't the production hardware)

** Efficiency: easy to lose
- Team of engineers hacking away on features
- \(\mathnormal{O(log\, n)}\) or less is required
- Easy to accidentally turn it into \(\mathnormal{O(n)}\) (or worse)
- I need a way to test for algorithmic efficiency

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I work with good engineers, but we're all human
- I was concerned about this
- I want the computer to help enforce this

** Testing for efficiency
- Run the same test with different sized inputs

#+BEGIN_LaTeX
\begin{align*}
\mathnormal{T_1} = & (time\, for\, run\, on\, data\, of\, size\: \mathnormal{N})\\
\mathnormal{T_2} = & (time\, for\, run\, on\, data\, of\, size\: \mathnormal{kN})\\
\end{align*}
\begin{align*}
\mathnormal{T \quad \propto} & \quad \mathnormal{N}\\
\mathnormal{T_1 = T(N) \quad =} & \quad \mathnormal{aN}\\
\mathnormal{T_2 = T(kN) \quad =} & \quad \mathnormal{akN}\\
\mathnormal{\frac{T_2}{T_1} \quad =} & \quad \mathnormal{k}
\end{align*}
#+END_LaTeX

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- empirical method
- explain

** Common cases
#+BEGIN_LaTeX
\begin{align*}
\mathnormal{O(1) \Rightarrow} & \mathnormal{\frac{T_2}{T_1} = 1} \\[0.5em]
\mathnormal{O(log\, n) \Rightarrow} & \mathnormal{\frac{T_2}{T_1} = 1 + \frac{log(k)}{log(N)}} \\[0.5em]
\mathnormal{O(n) \Rightarrow} & \mathnormal{\frac{T_2}{T_1} = k} \\[0.5em]
\mathnormal{O(n\, log\, n) \Rightarrow} & \mathnormal{\frac{T_2}{T_1} = k\, (1 + \frac{log(k)}{log(N)})} \\[0.5em]
\mathnormal{O(n^2) \Rightarrow} & \mathnormal{\frac{T_2}{T_1} = k^2}
\end{align*}
#+END_LaTeX

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- simple math to get figures for each bucket I care about

** This sounds easy, but...
- Timing is hard
  - sensitive to machine load
  - sensitive to caching effects (CPU/OS)
  - sensitive to timing function: granularity/perf
- Statistical mitigation
- Somewhat careful choice of \(\mathnormal{k}\), \(\mathnormal{N}\)
  - I settled on (\(\mathnormal{N = 100, k = 32}\))

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Statistical mitigation = run multiple times, discard outliers, average
  - be clear: this is for machine effects
  - multiple runs occur on the same data
- constants need to be big enough to elicit the required effect
- but small enough not to make the test slow
- fast, high frequency timing function is desirable
- The nice thing is that you don't need to run this optimized
  - optimization tends only to make things better

** Different-sized inputs

*** block                                                 :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
Where do you get different-sized inputs?\\
You can let the test make them...\\[1\baselineskip]
\hrule
\end{center}

*** Let the test make them                                      :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{const int MULT = 32;\\
const int N = 32;\\
...\\
{\color{sh_comment}\textit{// run 1 - with size N}}\\
\hilight{auto sampleTime1 = test->Run(N);}\\
test->Teardown();\\[1\baselineskip]
test->Setup();\\
{\color{sh_comment}\textit{// run 2 - with size kN}}\\
auto sampleTime2 = test->Run(N * MULT);\\
...\\}
\end{scriptsize}

*** Let the test make them                                      :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{const int MULT = 32;\\
const int N = 32;\\
...\\
{\color{sh_comment}\textit{// run 1 - with size N}}\\
auto sampleTime1 = test->Run(N);\\
test->Teardown();\\[1\baselineskip]
test->Setup();\\
{\color{sh_comment}\textit{// run 2 - with size kN}}\\
\hilight{auto sampleTime2 = test->Run(N * MULT);}\\
...\\}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Affects the timing if done naively (i.e. wrongly)
  - Adds an \(\mathnormal{O(n)}\) component to the test
  - So move the timing code inside the test also
- Boilerplate in test code
- It's not ideal...

** Let the test make them?
Result: a typical test
- ~40 lines setup
- ~10 lines timing
- ~5 lines actual logic
- ~5 lines test macros
Yuck.

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I was working with objects that needed some setup
- monolithic classes, remember?

** Let the test make them?
- It works well enough to give me confidence
  - Matchmaking won't blow up with a million players
- So I lived with this for a while...
- But I'm lazy, I don't want to maintain all this code

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Shipped with this because sometimes good enough is good enough

* Property-based testing
** Autogenerating test inputs
\begin{center}
Problem 3: Generating test input automatically.\\[2\baselineskip]
(Laziness, Impatience, Hubris. Check.)
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I'm a student of Haskell (Quickcheck)
- The idea of property-Based testing
- Usually established in languages with reflection
- Or sufficiently powerful type systems
- Explain property-based testing

** Wish-driven development
\begin{center}
What I have\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{DEF_TEST(TestName, Suite)\\
\string{\\
\ \ ...\\
\ \ return test_result;\\
\string}}
\end{scriptsize}

\begin{center}
What I want\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{DEF_PROPERTY(TestName, Suite, \hilight{const string\& s})\\
\string{\\
\ \ {\color{sh_comment}\textit{// do something with s\\
\ \ // that should be true for any input}}\\
\ \ ...\\
\ \ return property_holds;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I need a way to generate values of "any type"
- There are lots of things we already do for any type (eg print)

** How to generate \texttt{TYPE}?
\begin{center}
Use a template, naturally\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{template <typename T>\\
struct Arbitrary\\
\string{\\
\ \ static T generate(size_t {\color{sh_comment}\textit{/*generation*/}}, unsigned long int {\color{sh_comment}\textit{/*seed*/}})\\
\ \ \string{\\
\ \ \ \ return T();\\
\ \ \string}\\
\string};\\[1\baselineskip]}
\end{scriptsize}

\begin{center}
\hrule\leavevmode\\[1\baselineskip]
And specialize...
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- The basic form
- generation is some idea of how complex the generated thing is
- and plumb through a random seed for reproducibility

** Specializing \texttt{Arbitrary<T>}
- Easy to write \texttt{Arbitrary<T>} for arithmetic types
- Front-load likely edge cases
  - \texttt{0}
  - \texttt{numeric_limits<T>::min()}
  - \texttt{numeric_limits<T>::max()}
- Otherwise use uniform distribution over range

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Explain
- Generating arithmetic types is easy

** Specializing \texttt{Arbitrary<T>}
\begin{center}
For \texttt{int}-like types\\[1\baselineskip]
\hrule
\end{center}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{static int generate(size_t g, unsigned long int seed)\\
\string{\\
\ \ switch (g)\\
\ \ \string{\\
\ \ \ \ case 0:\ \hilight{return 0;}\\
\ \ \ \ case 1:\ \hilight{return std::numeric_limits<T>::min();}\\
\ \ \ \ case 2:\ \hilight{return std::numeric_limits<T>::max();}\\
\ \ \ \ default:\\
\ \ \ \ \string{\\
\ \ \ \ \ \ std::mt19937 gen(seed);\\
\ \ \ \ \ \ std::uniform_int_distribution<T> dis(\\
\ \ \ \ \ \ \ \ std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\\
\ \ \ \ \ \ return dis(gen);\\
\ \ \ \ \string}\\
\ \ \string}\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{static int generate(size_t g, unsigned long int seed)\\
\string{\\
\ \ switch (g)\\
\ \ \string{\\
\ \ \ \ case 0:\ return 0;\\
\ \ \ \ case 1:\ return std::numeric_limits<T>::min();\\
\ \ \ \ case 2:\ return std::numeric_limits<T>::max();\\
\ \ \ \ default:\\
\ \ \ \ \string{\\
\ \ \ \ \ \ \hilight{std::mt19937 gen(seed);}\\
\ \ \ \ \ \ \hilight{std::uniform_int_distribution<T> dis(}\\
\ \ \ \ \ \ \ \ \hilight{std::numeric_limits<T>::min(), std::numeric_limits<T>::max());}\\
\ \ \ \ \ \ \hilight{return dis(gen);}\\
\ \ \ \ \string}\\
\ \ \string}\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- (Code formatted for slide: in reality, I don't create a mersenne twister on
  the stack every call)
- For bools, it's trivial
- For chars, generate printable values

** Specializing \texttt{Arbitrary<T>}
- Once we have \texttt{Arbitrary<T>} for fundamental types...
- Easy to write for compound types
  - \texttt{vector<T>} etc
  - \texttt{generate} works in terms of \texttt{generate} on the contained type
  - ADT-like approach

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Compound types are made of other types of course
- Can be built up recursively

** Specializing \texttt{Arbitrary<T>}
\begin{center}
For compound types (eg \texttt{vector})\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{static vector<T> generate(size_t g, unsigned long int seed)\\
\string{\\
\ \ vector<T> v;\\
\ \ size_t n = 10 * ((g / 100) + 1);\\
\ \ v.reserve(n);\\
\ \ std::generate_n(\\
\ \ \ \ std::back_inserter(v), n, [\&] () \string{\\
\ \ \ \ \ \ \hilight{return Arbitrary<T>::generate(g, seed++);} \string});\\
\ \ return v;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Explain
- The idea of a "generation" deals with things like how long to make vectors, strings etc
- Generate for compound type works recursively by generating the contained types

** How to make a property test?
\begin{center}
What I want\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{DEF_PROPERTY(TestName, Suite, \hilight{const string\& s})\\
\string{\\
\ \ {\color{sh_comment}\textit{// do something with s\\
\ \ // that should be true for any input}}\\
\ \ ...\\
\ \ return property_holds;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- So far, I know how to generate the type
- Now I needed to figure out how to deal with the test
- Normally, tests don't have arguments

** Test macros expand into functions
\begin{center}
Macro...\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{DEF_PROPERTY(TestName, Suite, const string\& s)\\
\string{\\
\ \ ...\\
\string}}
\end{scriptsize}

\begin{center}
Expands to...\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{struct NonceStruct\\
\string{\\
\ \ ...\\
\ \ bool operator()(const string\& s);\\
\string};\\
bool NonceStruct::operator()(const string\& s)\\
\string{\\
\ \ ...\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- the macro instantiates a function object
- I can discover the type of the operator() argument

** Discover the type of the function argument
\begin{center}
Simple \texttt{function_traits} template\\[1\baselineskip]
\hrule
\end{center}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{template <typename T>\\
struct function_traits\\
\ \ :\ public function_traits<\hilight{decltype(\&T::operator())}>\\
\string{\string};\\[1\baselineskip]
template <typename R, typename A>\\
struct function_traits<R(A)>\\
\string{\\
\ \ using argType = A;\\
\string};\\[1\baselineskip]
template <typename C, typename R, typename A>\\
struct function_traits<R(C::*)(A)>\\
\ \ :\ public function_traits<R(A)>\\
\string{\string};\\[1\baselineskip]
...\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{template <typename T>\\
struct function_traits\\
\ \ :\ public function_traits<decltype(\&T::operator())>\\
\string{\string};\\[1\baselineskip]
template <typename R, typename A>\\
struct function_traits<R(A)>\\
\string{\\
\ \ using argType = A;\\
\string};\\[1\baselineskip]
template <typename C, typename R, typename A>\\
struct function_traits<\hilight{R(C::*)(A)}>\\
\ \ :\ public function_traits<R(A)>\\
\string{\string};\\[1\baselineskip]
...\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{template <typename T>\\
struct function_traits\\
\ \ :\ public function_traits<decltype(\&T::operator())>\\
\string{\string};\\[1\baselineskip]
template <typename R, typename A>\\
struct function_traits<R(A)>\\
\string{\\
\ \ \hilight{using argType = A;}\\
\string};\\[1\baselineskip]
template <typename C, typename R, typename A>\\
struct function_traits<R(C::*)(A)>\\
\ \ :\ public function_traits<R(A)>\\
\string{\string};\\[1\baselineskip]
...\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- googling function traits turns up something very like this
- explain (slowly)
- omitted further specializations dealing with various const & ref qualifiers
- now I know
  - The argument type to generate
  - How to generate it
- All I need to do is figure out how to write Run() for a property test
- I need to take the operator() function, whose type varies for each test
- And make it callable in a uniform way
- Single-function interface on a varying-type object
- tailor-made for type erasure

** Implement a \texttt{Run} function
\begin{center}
\texttt{Run()} for a property test\\[1\baselineskip]
\hrule
\end{center}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{{\color{sh_comment}\textit{// DEF_PROPERTY(TestName, Suite, TYPE) becomes...}}\\
struct NonceStruct :\ public Test\\
\string{\\
\ \ ...\\
\ \ virtual \hilight{bool Run()} override\\
\ \ \string{\\
\ \ \ \ {\color{sh_comment}\textit{// Property will type-erase NonceStruct, discover its argument type}}\\
\ \ \ \ Property p(*this);\\
\ \ \ \ {\color{sh_comment}\textit{// check() generates arguments to call NonceStruct(TYPE)}}\\
\ \ \ \ return p.check();\\
\ \ \string}\\
\ \ ...\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{{\color{sh_comment}\textit{// DEF_PROPERTY(TestName, Suite, TYPE) becomes...}}\\
struct NonceStruct :\ public Test\\
\string{\\
\ \ ...\\
\ \ virtual bool Run() override\\
\ \ \string{\\
\ \ \ \ {\color{sh_comment}\textit{// Property will type-erase NonceStruct, discover its argument type}}\\
\ \ \ \ Property p(\hilight{*this});\\
\ \ \ \ {\color{sh_comment}\textit{// check() generates arguments to call NonceStruct(TYPE)}}\\
\ \ \ \ return p.check();\\
\ \ \string}\\
\ \ ...\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{{\color{sh_comment}\textit{// DEF_PROPERTY(TestName, Suite, TYPE) becomes...}}\\
struct NonceStruct :\ public Test\\
\string{\\
\ \ ...\\
\ \ virtual bool Run() override\\
\ \ \string{\\
\ \ \ \ {\color{sh_comment}\textit{// Property will type-erase NonceStruct, discover its argument type}}\\
\ \ \ \ Property p(*this);\\
\ \ \ \ {\color{sh_comment}\textit{// check() generates arguments to call NonceStruct(TYPE)}}\\
\ \ \ \ return \hilight{p.check();}\\
\ \ \string}\\
\ \ ...\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Run() function is inherited from Test: this is quite standard
- "this" is the struct whose operator() varies
  - gets type-erased by Property
- Property exposes check() which calls the type-erased operator()

** \texttt{Property} type-erases \texttt{NonceStruct}
*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{struct Property\\
\string{\\
\ \ \hilight{template <typename F>}\\
\ \ \hilight{Property(const F\& f)}\\
\ \ \ \ \hilight{:\ m_internal(std::make_unique<Internal<F>{}>(f))}\\
\ \ \hilight{\string{\string}}\\[1\baselineskip]
\ \ bool check(...)\\
\ \ \string{\\
\ \ \ \ return m_internal->check(...);\\
\ \ \string}\\[1\baselineskip]
\ \ struct InternalBase\\
\ \ \string{\\
\ \ \ \ virtual \textasciitilde{}InternalBase() \string{\string}\\
\ \ \ \ virtual bool check(...)\ = 0;\\
\ \ \string};\\[1\baselineskip]
\ \ template <typename U>\\
\ \ struct Internal :\ public InternalBase\\
\ \ \string{ ...\ \string};\\[1\baselineskip]
\ \ \hilight{std::unique_ptr<InternalBase> m_internal;}\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{struct Property\\
\string{\\
\ \ template <typename F>\\
\ \ Property(const F\& f)\\
\ \ \ \ :\ m_internal(std::make_unique<Internal<F>{}>(f))\\
\ \ \string{\string}\\[1\baselineskip]
\ \ \hilight{bool check(...)}\\
\ \ \string{\\
\ \ \ \ \hilight{return m_internal->check(...);}\\
\ \ \string}\\[1\baselineskip]
\ \ struct InternalBase\\
\ \ \string{\\
\ \ \ \ virtual \textasciitilde{}InternalBase() \string{\string}\\
\ \ \ \ \hilight{virtual bool check(...)\ = 0;}\\
\ \ \string};\\[1\baselineskip]
\ \ template <typename U>\\
\ \ struct Internal :\ public InternalBase\\
\ \ \string{ ...\ \string};\\[1\baselineskip]
\ \ std::unique_ptr<InternalBase> m_internal;\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <3>
:END:
\begin{scriptsize}
\texttt{struct Property\\
\string{\\
\ \ template <typename F>\\
\ \ Property(const F\& f)\\
\ \ \ \ :\ m_internal(std::make_unique<Internal<F>{}>(f))\\
\ \ \string{\string}\\[1\baselineskip]
\ \ bool check(...)\\
\ \ \string{\\
\ \ \ \ return m_internal->check(...);\\
\ \ \string}\\[1\baselineskip]
\ \ struct InternalBase\\
\ \ \string{\\
\ \ \ \ virtual \textasciitilde{}InternalBase() \string{\string}\\
\ \ \ \ virtual bool check(...)\ = 0;\\
\ \ \string};\\[1\baselineskip]
\ \ \hilight{template <typename U>}\\
\ \ \hilight{struct Internal :\ public InternalBase}\\
\ \ \hilight{\string{ ...\ \string};}\\[1\baselineskip]
\ \ std::unique_ptr<InternalBase> m_internal;\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- formatted for slide
- standard type-erasure pattern
- here's the constructor that's a template and captures the passed-in type
- here's the stored type-erased thing
- here's the exposed interface: the check function
- the omitted args are the generation and random seed params we saw earlier
  that will be used with the call to Arbitrary::generate
- let's look inside Internal

** \texttt{Property} type-erases \texttt{NonceStruct}
\begin{center}
Inside \texttt{Property}\\[1\baselineskip]
\hrule
\end{center}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{template <typename T>\\
struct Internal :\ public InternalBase\\
\string{\\
\ \ ...\\[1\baselineskip]
\ \ \hilight{using paramType = std::decay_t<typename function_traits<T>::argType>;}\\[1\baselineskip]
\ \ virtual bool check(...)\\
\ \ \string{\\
\ \ \ \ ...\\
\ \ \ \ {\color{sh_comment}\textit{// generate a value of the right type}}\\
\ \ \ \ \hilight{paramType p = Arbitrary<paramType>::generate(...);}\\
\ \ \ \ {\color{sh_comment}\textit{// feed it to the struct's operator()}}\\
\ \ \ \ return m_t(p);\\
\ \ \string}\\[1\baselineskip]
\ \ T m_t;\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{template <typename T>\\
struct Internal :\ public InternalBase\\
\string{\\
\ \ ...\\[1\baselineskip]
\ \ using paramType = std::decay_t<typename function_traits<T>::argType>;\\[1\baselineskip]
\ \ virtual bool check(...)\\
\ \ \string{\\
\ \ \ \ ...\\
\ \ \ \ {\color{sh_comment}\textit{// generate a value of the right type}}\\
\ \ \ \ paramType p = Arbitrary<paramType>::generate(...);\\
\ \ \ \ {\color{sh_comment}\textit{// feed it to the struct's operator()}}\\
\ \ \ \ \hilight{return m_t(p);}\\
\ \ \string}\\[1\baselineskip]
\ \ \hilight{T m_t;}\\
\string};\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- check generates a value using Arbitrary::generate
- passes it to the operator() of the NonceStruct

** A short demo
\begin{center}
(Demo)
\end{center}

** Now we have property tests
- Macro expands \texttt{NonceStruct} with \texttt{operator()}
- \texttt{Property} type-erases \texttt{NonceStruct}
- \texttt{Property::Check} does:
  - \texttt{function_traits} discovery of the argument type \texttt{T}
  - \texttt{Arbitrary<T>::generate} to make a \texttt{T}
  - Call \texttt{NonceStruct::operator()}
- And plumb through parameters like number of checks, random seed

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- recap
- now we can use this ability to generate to power algorithmic tests
- but before we get to that, shrink

** Better checks for compound types
\begin{center}
When a check fails, find a minimal failure case\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{template <typename T>\\
struct Arbitrary\\
\string{\\
\ \ static std::vector<T> shrink(const T\& /*t*/)\\
\ \ \string{\\
\ \ \ \ return std::vector<T>();\\
\ \ \string}\\
\string};\\[1\baselineskip]}
\end{scriptsize}

\begin{center}
\hrule\leavevmode\\[1\baselineskip]
\texttt{shrink} returns a \texttt{vector} of "reduced" \texttt{T}'s
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- borrowed from Quickcheck
- we can do more than just generate
- shrink returns a vector of T's

** Better checks for compound types
\begin{center}
A simple binary search\\[1\baselineskip]
\hrule
\end{center}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{static std::vector<std::basic_string<T>{}> shrink(\\
\ \ const std::basic_string<T>\& t)\\
\string{\\
\ \ std::vector<std::basic_string<T>{}> v;\\
\ \ \hilight{if (t.size() < 2)}\\
\ \ \ \ \hilight{return v;}\\
\ \ auto l = t.size() / 2;\\
\ \ v.push_back(t.substr(0, l));\\
\ \ v.push_back(t.substr(l));\\
\ \ return v;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{static std::vector<std::basic_string<T>{}> shrink(\\
\ \ const std::basic_string<T>\& t)\\
\string{\\
\ \ std::vector<std::basic_string<T>{}> v;\\
\ \ if (t.size() < 2)\\
\ \ \ \ return v;\\
\ \ \hilight{auto l = t.size() / 2;}\\
\ \ \hilight{v.push_back(t.substr(0, l));}\\
\ \ \hilight{v.push_back(t.substr(l));}\\
\ \ return v;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** block                                                 :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\hrule\leavevmode\\[1\baselineskip]
Call \texttt{shrink} repeatedly to find a minimal fail case
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- base case: return empty vector
- recurse, making the returned vector elements smaller
- for the containers, just use a binary search strategy
- explain how the calling code will follow failing cases

** Demo #2
\begin{center}
(Demo)
\end{center}

* Testing scalability (II)
** Algorithmic test inputs
\begin{center}
Problem 2 revisited: Generating input for algorithmic tests.\\[2\baselineskip]
(I like to delete code.)
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Now I can take my property test code and apply it to the algorithmic
  complexity tests

** Testing for efficiency (again)
\begin{center}
Now the computer can generate \(\mathnormal{N}\), \(\mathnormal{kN}\) values\\[1\baselineskip]
\hrule
\end{center}

*** \texttt{Arbitrary<T>::generate()}                           :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{static vector<T> \hilight{generate}(size_t g, unsigned long int seed)\\
\string{\\
\ \ vector<T> v;\\
\ \ \hilight{size_t n = 10 * ((g / 100) + 1);}\\
\ \ v.reserve(n);\\
\ \ std::generate_n(\\
\ \ \ \ std::back_inserter(v), n, [\&] () \string{\\
\ \ \ \ \ \ return \hilight{Arbitrary<T>::generate}(g, seed++); \string});\\
\ \ return v;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** \texttt{Arbitrary<T>::generate_n()}                         :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{static vector<T> \hilight{generate_n}(size_t g, unsigned long int seed)\\
\string{\\
\ \ vector<T> v;\\
\ \ {\color{sh_comment}\textit{// use g directly instead of a "loose" value}}\\
\ \ v.reserve(g);\\
\ \ std::generate_n(\\
\ \ \ \ std::back_inserter(v), g, [\&] () \string{\\
\ \ \ \ \ \ return \hilight{Arbitrary<T>::generate_n}(g, seed++); \string});\\
\ \ return v;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** block                                                 :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\begin{center}
\hrule\leavevmode\\[1\baselineskip]
Add \texttt{generate_n} as a tighter form of \texttt{generate}
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- For algorithmic tests, we need to lock down a specific size
- Otherwise generate_n works exactly the same as generate
- the calling code doesn't need to follow failures
- these tests are just for timing

** Now I can write
\begin{center}
A sample complexity test\\[1\baselineskip]
\hrule
\end{center}

\begin{scriptsize}
\texttt{DEF_COMPLEXITY_PROPERTY(TestName, Suite, ORDER_N, const string\& s)\\
\string{\\
\ \ {\color{sh_comment}\textit{// something that's supposed to be order N...}}\\
\ \ ...\\
\ \ std::max_element(s.begin(), s.end());\\
\ \ ...\\
\string}\\[1\baselineskip]}
\end{scriptsize}

\begin{center}
\hrule\leavevmode\\[1\baselineskip]
And specialize \texttt{Arbitrary} for my own types as necessary\\
Much less boilerplate to maintain
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- can use O(1), O(log n), O(n), O(n log n), O(n^2)
- if the test comes in at or under the specified order, that's a pass
- specialize my own type generation:
  - random for average case data
  - bastard mode for worst case data
  - for ranges
  - unfortunately c++ has no newtype

** Demo #3
\begin{center}
(Demo)
\end{center}

** Before and After
#+begin_src c++
#+end_src
\begin{columns}
\begin{column}{0.4\textwidth}
\begin{minted}[frame=none,fontsize=\fontsize{2}{2.4}]{c++}
PERFORDERTEST_WITH_LEVEL(CoopGameFactory, MatchPerf, test::ORDER_1, 1)
{
  CoopGameFactory gf(version, FourCC(), 0);
  ConfigureFactory(&gf, 1, 4, 4);

  protocol::game_master::GameProperties properties;
  protocol::attribute::AttributeFilter* filter = properties.mutable_filter();
  filter->set_op(protocol::attribute::AttributeFilter::MATCH_ALL);

  // Fill the forming games list with a lot of games.
  for (size_t n = 0; n < numElements; ++n)
  {
    AttributeList attrs;
    attrs.Append("Foo", Variant::MakeInt(n + 1));
    attrs.ToProtocol(filter->mutable_attribute());

    vector<game::Player::Ptr> players;
    for (int i = 1; i <= 2; ++i)
    {
      game::Player::Ptr p(new game::Player);
      p->m_id = EntityId(EntityId::KIND_GAME_ACCOUNT, 0, i);
      players.push_back(p);
    }
    rpc::ObjectAddress subscriber;
    GameRequestId id = n;
    GameId gameId = ChannelImpl::GetNextChannelId(n);
    Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
    EXPECT_EQ(status, ERROR_OK);
  }
  EXPECT_EQ(GetVarValue("NumPlayersMatchingNow"), 2 * numElements);

  // Now measure matching performance. Add a registration and match it, n
  // times.
  AttributeList attrs;
  attrs.Append("Foo", Variant::MakeInt(numElements + 1));
  attrs.ToProtocol(filter->mutable_attribute());

  m_numcalls__ = 1000;
  int uniqueGameId = numElements;
  ptime start = microsec_clock::universal_time();
  for (size_t n = 0; n < m_numcalls__; ++n, ++uniqueGameId)
  {
    {
      vector<game::Player::Ptr> players;
      for (int i = 1; i <= 2; ++i)
      {
        game::Player::Ptr p(new game::Player);
        p->m_id = EntityId(EntityId::KIND_GAME_ACCOUNT, 0, i);
        players.push_back(p);
      }
      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }

    ++uniqueGameId;

    {
      vector<game::Player::Ptr> players;
      for (int i = 3; i <= 4; ++i)
      {
        game::Player::Ptr p(new game::Player);
        p->m_id = EntityId(EntityId::KIND_GAME_ACCOUNT, 0, i);
        players.push_back(p);
      }
      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }
  }
  time_duration t = microsec_clock::universal_time() - start;

  EXPECT_EQ(GetVarValue("NumPlayersMatchingNow"), 2 * numElements);
  EXPECT_EQ(GetVarValue("NumGamesNow"), m_numcalls__);
  EXPECT_EQ(GetVarValue("NumPlayersInGamesNow"), 4 * m_numcalls__);

  return t.total_microseconds();
}
\end{minted}
\end{column}

\begin{column}{0.4\textwidth}
\begin{onlyenv}<2>
\begin{minted}[frame=none,fontsize=\fontsize{2}{2.4}]{c++}
PERFORDERTEST_WITH_LEVEL(CoopGameFactory, MatchPerf, test::ORDER_1, 1)
{
  CoopGameFactory gf(version, FourCC(), 0);
  ConfigureFactory(&gf, 1, 4, 4);

  protocol::game_master::GameProperties properties;
  protocol::attribute::AttributeFilter* filter = properties.mutable_filter();
  filter->set_op(protocol::attribute::AttributeFilter::MATCH_ALL);

  // Fill the forming games list with a lot of games.
  for (size_t n = 0; n < numElements; ++n)
  {
    AttributeList attrs;
    attrs.Append("Foo", Variant::MakeInt(n + 1));
    attrs.ToProtocol(filter->mutable_attribute());

    vector<game::Player::Ptr> players;
    for (int i = 1; i <= 2; ++i)
    {
      game::Player::Ptr p(new game::Player);
      p->m_id = EntityId(EntityId::KIND_GAME_ACCOUNT, 0, i);
      players.push_back(p);
    }
    rpc::ObjectAddress subscriber;
    GameRequestId id = n;
    GameId gameId = ChannelImpl::GetNextChannelId(n);
    Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
    EXPECT_EQ(status, ERROR_OK);
  }
  EXPECT_EQ(GetVarValue("NumPlayersMatchingNow"), 2 * numElements);

  // Now measure matching performance. Add a registration and match it, n
  // times.
  AttributeList attrs;
  attrs.Append("Foo", Variant::MakeInt(numElements + 1));
  attrs.ToProtocol(filter->mutable_attribute());

  m_numcalls__ = 1000;
  int uniqueGameId = numElements;
  ptime start = microsec_clock::universal_time();
  for (size_t n = 0; n < m_numcalls__; ++n, ++uniqueGameId)
  {
    {
      vector<game::Player::Ptr> players;
      for (int i = 1; i <= 2; ++i)
      {
        game::Player::Ptr p(new game::Player);
        p->m_id = EntityId(EntityId::KIND_GAME_ACCOUNT, 0, i);
        players.push_back(p);
      }
      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }

    ++uniqueGameId;

    {
      vector<game::Player::Ptr> players;
      for (int i = 3; i <= 4; ++i)
      {
        game::Player::Ptr p(new game::Player);
        p->m_id = EntityId(EntityId::KIND_GAME_ACCOUNT, 0, i);
        players.push_back(p);
      }
      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }
  }
  time_duration t = microsec_clock::universal_time() - start;

  EXPECT_EQ(GetVarValue("NumPlayersMatchingNow"), 2 * numElements);
  EXPECT_EQ(GetVarValue("NumGamesNow"), m_numcalls__);
  EXPECT_EQ(GetVarValue("NumPlayersInGamesNow"), 4 * m_numcalls__);

  return t.total_microseconds();
}
\end{minted}
\end{onlyenv}
\begin{onlyenv}<3>
\begin{minted}[frame=none,fontsize=\fontsize{2}{2.4}]{c++}
PERFORDERTEST_WITH_LEVEL(CoopGameFactory, MatchPerf, test::ORDER_1, 1)
{



  protocol::game_master::GameProperties properties;
  protocol::attribute::AttributeFilter* filter = properties.mutable_filter();
  filter->set_op(protocol::attribute::AttributeFilter::MATCH_ALL);























  // Now measure matching performance. Add a registration and match it, n
  // times.
  AttributeList attrs;
  attrs.Append("Foo", Variant::MakeInt(numElements + 1));
  attrs.ToProtocol(filter->mutable_attribute());

  m_numcalls__ = 1000;
  int uniqueGameId = numElements;
  ptime start = microsec_clock::universal_time();
  for (size_t n = 0; n < m_numcalls__; ++n, ++uniqueGameId)
  {
    {
      vector<game::Player::Ptr> players;






      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }

    ++uniqueGameId;

    {
      vector<game::Player::Ptr> players;






      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }
  }
  time_duration t = microsec_clock::universal_time() - start;

  EXPECT_EQ(GetVarValue("NumPlayersMatchingNow"), 2 * numElements);
  EXPECT_EQ(GetVarValue("NumGamesNow"), m_numcalls__);
  EXPECT_EQ(GetVarValue("NumPlayersInGamesNow"), 4 * m_numcalls__);

  return t.total_microseconds();
}
\end{minted}
\end{onlyenv}
\begin{onlyenv}<4>
\begin{minted}[frame=none,fontsize=\fontsize{2}{2.4}]{c++}
PERFORDERTEST_WITH_LEVEL(CoopGameFactory, MatchPerf, test::ORDER_1, 1)
{



  protocol::game_master::GameProperties properties;
  protocol::attribute::AttributeFilter* filter = properties.mutable_filter();
  filter->set_op(protocol::attribute::AttributeFilter::MATCH_ALL);























  // Now measure matching performance. Add a registration and match it, n
  // times.
  AttributeList attrs;
  attrs.Append("Foo", Variant::MakeInt(numElements + 1));
  attrs.ToProtocol(filter->mutable_attribute());


  int uniqueGameId = numElements;



    {
      vector<game::Player::Ptr> players;






      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }

    ++uniqueGameId;

    {
      vector<game::Player::Ptr> players;






      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }



  EXPECT_EQ(GetVarValue("NumPlayersMatchingNow"), 2 * numElements);




}
\end{minted}
\end{onlyenv}
\begin{onlyenv}<5>
\begin{minted}[frame=none,fontsize=\fontsize{2}{2.4}]{c++}
PERFORDERTEST_WITH_LEVEL(CoopGameFactory, MatchPerf, test::ORDER_1, 1)
{



  protocol::game_master::GameProperties properties;
  protocol::attribute::AttributeFilter* filter = properties.mutable_filter();
  filter->set_op(protocol::attribute::AttributeFilter::MATCH_ALL);























  // Now measure matching performance. Add a registration and match it, n
  // times.
  AttributeList attrs;
  attrs.Append("Foo", Variant::MakeInt(numElements + 1));
  attrs.ToProtocol(filter->mutable_attribute());






    {
      vector<game::Player::Ptr> players;






      rpc::ObjectAddress subscriber;
      GameRequestId id = uniqueGameId;
      GameId gameId = ChannelImpl::GetNextChannelId(uniqueGameId);
      Error status = gf.RegisterPlayers(players, subscriber, &properties, gameId, id);
      EXPECT_EQ(status, ERROR_OK);
    }




















  EXPECT_EQ(GetVarValue("NumPlayersMatchingNow"), 2 * numElements);




}
\end{minted}
\end{onlyenv}
\end{column}

\end{columns}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Get rid of
  - generation code
  - timing code
- refactor code made unnecessary by the new framework
- ~80 lines -> ~20 lines

* Future thoughts
** The reward for good work is more work
\begin{center}
Status quo/future possibilities.\\[2\baselineskip]
(People are never satisfied.)
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Arbitrary opens up new possibilities
- Next slide is a roundup

** Where I am now
- Dependency injection (little work in constructors)
- Separate logic from interaction (even in monolithic classes)
- Regular tests for "normal, identified" cases
- Timed tests when I'm optimizing
- Property-based tests for invariants
- Algorithmic complexity tests for scalability confidence

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- regular tests are still good
- property tests make you think harder
- in practice, the efficiency bar for Battle.net efficiency is < O(n)

** The future?
- \texttt{Arbitrary} opens the door for fuzz testing?
- Alternative walk strategies through the input space
  - Hilbert
  - Morton
  - etc
- Using \texttt{Arbitrary} to find poorly-performing data (P99)
- I'm still lazy; the computer isn't doing enough for me yet

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- Fuzz testing is possible, but I didn't need it so much at the protocol level
  - Protobufs have sum and product types now
  - Illegal states can be unrepresentable
- Exercise poor performance in a couple of ways
  - Make tests do bad things
  - Make Arbitrary generation give bad data

** Battle.net is still highly...
- Distributed
- Asynchronous
- Configured
- Architecture-varied

\begin{center}
But more parts of it are well-tested before they leave a developer's machine.\\[1\baselineskip]
And I'm more confident changing code with a safety net for correctness/efficiency/scalability.
\end{center}

** Thanks for listening
\begin{center}
\textit{Errors using inadequate data are much less\\
than those using no data at all.}\\
\hfill \footnotesize{- Charles Babbage}\\[2\baselineskip]
C++14 code: \texttt{https://github.com/elbeno/testinator}\\[2\baselineskip]
Me: \texttt{\href{mailto:bdeane@blizzard.com}{bdeane@blizzard.com}, \href{http://www.twitter.com/ben_deane}{@ben_deane}}
\end{center}

* Epilogue                                                       :B_appendix:
:PROPERTIES:
:BEAMER_env: appendix
:END:
\addtocounter{framenumber}{-1}

** Epilogue: more on properties
\begin{center}
Cool, can you do multiple arguments?\\[1\baselineskip]
\hrule
\end{center}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{DEF_PROPERTY(TestName, Suite, \hilight{const string\& s})\\
\string{\\
\ \ {\color{sh_comment}\textit{// do something with s\\
\ \ // that should be true for any input}}\\
\ \ ...\\
\ \ return property_holds;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{DEF_PROPERTY(TestName, Suite, \hilight{const string\& s, int i})\\
\string{\\
\ \ {\color{sh_comment}\textit{// do something with s, i\\
\ \ // that should be true for any input}}\\
\ \ ...\\
\ \ return property_holds;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- when people see me riding a unicycle, they ask if I can juggle at the same time

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** DEF_PROPERTY uses \texttt{\_\_VA\_ARGS\_\_}
\begin{scriptsize}
\texttt{#define DEF_PROPERTY(NAME, SUITE, \hilight{...}) \textbackslash\\
...\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbackslash\\
bool operator()(\hilight{\_\_VA\_ARGS\_\_})\\[1\baselineskip]
DEF_PROPERTY(TestName, Suite, const string\& s, int i)\\
\string{\\
\ \ ...\\
\string}}
\end{scriptsize}

\begin{center}
Expands to...\\[1\baselineskip]
\end{center}

\begin{scriptsize}
\texttt{struct NonceStruct\\
\string{\\
\ \ ...\\
\ \ bool operator()(const string\& s, int i);\\
\string};\\
bool NonceStruct::operator()(const string\& s, int i)\\
\string{\\
\ \ ...\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- C++ has variadic macros in the standard now

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** \texttt{function_traits} captures args in a tuple
*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{template <typename R, typename...\ A>\\
struct function_traits<R(A...)>\\
\string{\\
\ \ \hilight{using argTuple = std::tuple<std::decay_t<A>...>;}\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// apply a function to a tuple of arguments}}\\
\ \ template <typename F>\\
\ \ static R apply(F\& f, const argTuple\& t)\\
\ \ \string{\\
\ \ \ \ return unpackApply(f, t, std::index_sequence_for<A...>());\\
\ \ \string}\\[1\baselineskip]
\ \ template <typename F, std::size_t...\ Is>\\
\ \ static R unpackApply(F\& f, const argTuple\& t, std::index_sequence<Is...>)\\
\ \ \string{\\
\ \ \ \ return f(std::get<Is>(t)...);\\
\ \ \string}\\
\ \ ...\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{template <typename R, typename...\ A>\\
struct function_traits<R(A...)>\\
\string{\\
\ \ using argTuple = std::tuple<std::decay_t<A>...>;\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// apply a function to a tuple of arguments}}\\
\ \ template <typename F>\\
\ \ static R apply(F\& f, const argTuple\& t)\\
\ \ \string{\\
\ \ \ \ return unpackApply(f, t, \hilight{std::index_sequence_for<A...>()});\\
\ \ \string}\\[1\baselineskip]
\ \ template <typename F, std::size_t...\ Is>\\
\ \ static R unpackApply(F\& f, const argTuple\& t, std::index_sequence<Is...>)\\
\ \ \string{\\
\ \ \ \ return \hilight{f(std::get<Is>(t)...)};\\
\ \ \string}\\
\ \ ...\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I was surprised how easy it was to apply a type transformation
- This is basically apply from the library fundamentals TS
 - But without the forwarding references

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** Shrinking tuples
- All property tests effectively take tuples as arguments
- So I need a way to shrink tuples
- First, think about pair
  - shrink first -> vector
  - shrink second -> vector
  - cartesian product of vectors?

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- tuples were a relatively late addition
- at first I didn't implement shrink very well
- I went back to pair and I had a comment there
- cartesian product not necessary because of machinery
- N+M solution

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** Shrinking pairs
*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{static std::vector<std::pair<T1, T2>{}> shrink(const std::pair<T1, T2>\& p)\\
\string{\\
\ \ std::vector<std::pair<T1, T2>{}> ret\string{\string};\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// shrink the first}}\\
\ \ auto first_v = \hilight{Arbitrary<T1>::shrink(p.first)};\\
\ \ for (T1\& e :\ first_v)\\
\ \ \string{\\
\ \ \ \ ret.push_back(\hilight{std::make_pair(std::move(e), p.second)});\\
\ \ \string}\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// shrink the second}}\\
\ \ auto second_v = Arbitrary<T2>::shrink(p.second);\\
\ \ for (T2\& e :\ second_v)\\
\ \ \string{\\
\ \ \ \ ret.push_back(std::make_pair(p.first, std::move(e)));\\
\ \ \string}\\[1\baselineskip]
\ \ return ret;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{static std::vector<std::pair<T1, T2>{}> shrink(const std::pair<T1, T2>\& p)\\
\string{\\
\ \ std::vector<std::pair<T1, T2>{}> ret\string{\string};\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// shrink the first}}\\
\ \ auto first_v = Arbitrary<T1>::shrink(p.first);\\
\ \ for (T1\& e :\ first_v)\\
\ \ \string{\\
\ \ \ \ ret.push_back(std::make_pair(std::move(e), p.second));\\
\ \ \string}\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// shrink the second}}\\
\ \ auto second_v = \hilight{Arbitrary<T2>::shrink(p.second)};\\
\ \ for (T2\& e :\ second_v)\\
\ \ \string{\\
\ \ \ \ ret.push_back(\hilight{std::make_pair(p.first, std::move(e))});\\
\ \ \string}\\[1\baselineskip]
\ \ return ret;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I thought about doing the cartesian product
- like applicative on lists in haskell

ghci> [(\(x,y) -> (1,y)), (\(x,y) -> (2,y))] <*> [(0,4),(0,5),(0,6)]

[(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)]

- but the N+M solution works just fine
- when you're done following the first shrink path, use the second

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** From pairs to tuples
- So I go to cppreference.com
  - \texttt{make_tuple}
  - \texttt{tie}
  - \texttt{forward_as_tuple}
  - \texttt{std::get}
  - \texttt{tuple_cat}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I see these things (go through them)
- tuple_cat? hmmm...

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** From pairs to tuples
- \texttt{first} is \texttt{std::get<0>()}
  - or \texttt{tuple_head()}?
- \texttt{second} is \texttt{tuple_tail()}
- \texttt{make_pair} is \texttt{tuple_cons}
  - put a head together with a tail

\begin{center}
\leavevmode\\[1\baselineskip]
(Pretend these functions exist so we can write \texttt{shrink} for tuples)
\end{center}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- I've done some functional programming

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** Shrinking tuples
*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{static std::vector<std::tuple<Ts...>{}> shrink(const std::tuple<Ts...>\& t)\\
\string{\\
\ \ std::vector<std::tuple<Ts...>{}> ret\string{\string};\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// shrink the head}}\\
\ \ using H = std::decay_t<decltype(std::get<0>(t))>;\\
\ \ auto head_v = Arbitrary<H>::shrink(\hilight{std::get<0>(t)});\\
\ \ for (H\& e :\ head_v)\\
\ \ \string{\\
\ \ \ \ ret.push_back(\hilight{tuple_cons(std::move(e), tuple_tail(t))});\\
\ \ \string}\\[1\baselineskip]
\ \ ...\\[1\baselineskip]
\ \ return ret;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{static std::vector<std::tuple<Ts...>{}> shrink(const std::tuple<Ts...>\& t)\\
\string{\\
\ \ std::vector<std::tuple<Ts...>{}> ret\string{\string};\\[1\baselineskip]
\ \ ...\\[1\baselineskip]
\ \ {\color{sh_comment}\textit{// shrink the tail recursively}}\\
\ \ using T = std::decay_t<decltype(tuple_tail(t))>;\\
\ \ auto tail_v = Arbitrary<T>::shrink(\hilight{tuple_tail(t)});\\
\ \ for (T\& e :\ tail_v)\\
\ \ \string{\\
\ \ \ \ ret.push_back(\hilight{tuple_cons(std::get<0>(t), std::move(e))});\\
\ \ \string}\\[1\baselineskip]
\ \ return ret;\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- pretend these exist
- as with pairs, so with tuples
- first shrink the head, cons them onto the tail
- then shrink the tail (it will work recursively)
- cons normal heads on to the shrunk tails

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** \texttt{tuple_cons} and \texttt{tuple_tail}
*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <1>
:END:
\begin{scriptsize}
\texttt{template <typename U, typename T>\\
auto tuple_cons(U\&\& u, T\&\& t)\\
\string{\\
\ \ using Tuple = std::decay_t<T>;\\
\ \ return tuple_cons(std::forward<U>(u), std::forward<T>(t),\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hilight{std::make_index_sequence<std::tuple_size<Tuple>::value>()});\\
\string}\\[1\baselineskip]
template <typename U, typename T, std::size_t ...Is>\\
auto tuple_cons(U\&\& u, T\&\& t, std::index_sequence<Is...>)\\
\string{\\
\ \ return std::make_tuple(std::forward<U>(u),\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hilight{std::get<Is>(std::forward<T>(t))...});\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** only                                                        :B_onlyenv:
:PROPERTIES:
:BEAMER_env: onlyenv
:BEAMER_act: <2>
:END:
\begin{scriptsize}
\texttt{template <typename T>\\
auto tuple_tail(T\&\& t)\\
\string{\\
\ \ using Tuple = std::decay_t<T>;\\
\ \ return tuple_tail(std::forward<T>(t),\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::make_index_sequence<\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hilight{std::tuple_size<Tuple>::value - 1}>());\\
\string}\\[1\baselineskip]
template <typename T, std::size_t ...Is>\\
auto tuple_tail(T\&\& t, std::index_sequence<Is...>)\\
\string{\\
\ \ return std::make_tuple(std::get<\hilight{Is + 1}>(std::forward<T>(t))...);\\
\string}\\[1\baselineskip]}
\end{scriptsize}

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- tuple_cons is easy (explain)
- tuple_tail (explain)
- the power of tuple, variadic templates and index_sequence is great

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** Shrinking tuples
- Shrink head -> shrunken heads
- Cons shrunken heads onto normal tail


- Shrink tail -> shrunken tails
- Cons normal head onto shrunken tails

*** notes                                                        :B_noteNH:
:PROPERTIES:
:BEAMER_env: noteNH
:END:
- easy
- and that's really it

* Epilogue                                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
\addtocounter{framenumber}{-1}

** Thanks for listening (again)
\begin{center}
C++14 code: \texttt{https://github.com/elbeno/testinator}\\[2\baselineskip]
Me: \texttt{\href{mailto:bdeane@blizzard.com}{bdeane@blizzard.com}, \href{http://www.twitter.com/ben_deane}{@ben_deane}}
\end{center}

* Notes                                                              :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:

- Introductory (short)
- Brief overview of Battle.net server topology
- The problem: moving beyond "easy-mode" unit testing of base libraries to testing real components with real interactions, IO, configuration, etc

- Designing for testability
- Separating and injecting dependencies
- Test-friendly class hierarchy design
- Identifying invariants, structuring logic for tests

- Testing strategies (and the C++ that powers them)
- Regular edge cases
- Planning for and testing failure in a distributed system
- Gaining confidence in scalability without incurring the cost of running a full environment*
- Property-based testing*

> ----------- REVIEW -----------
> I'm alway trying to increase the testing-related content at C++Now.
>
> In my opinion, C++ programmers don't talk and think enough about
> testing and don't design for testability. It think that younger
> languages were created after the TDD revolution and TDD is embedded in
> their culture. This is not true for C++, so we have to play catchup.
> Sessions like the one that Ben has submitted are step in that direction.
>
> Ben's project was designed with testability in mind and was also one
> with a particular testing challenge (testing at the required scale
> isn't really possible). The lessons learned from this project will be
> valuable to C++ developers.
>
>
> ----------------------- REVIEW 2 ---------------------
> PAPER: 3
> TITLE: Testing Battle.net (before deploying to millions of players)
> AUTHORS: Ben Deane
>
> OVERALL EVALUATION: 3 (strong accept)
> REVIEWER'S CONFIDENCE: 4 (high)
>
> ----------- REVIEW -----------
> Let's not waste time on commenting a keynote-quality submission.
>
>
> ----------------------- REVIEW 3 ---------------------
> PAPER: 3
> TITLE: Testing Battle.net (before deploying to millions of players)
> AUTHORS: Ben Deane
>
> OVERALL EVALUATION: 3 (strong accept)
> REVIEWER'S CONFIDENCE: 4 (high)
>
> ----------- REVIEW -----------
> This is the kind of talk that I look forward to hearing.  A talk on
> practical usage of C++ in dirty real world applications, and
> battle.net sounds about as dirty as they get.
>
> Large-scale deployment, heavy client scale-up and testing are issues I
> face daily and I hope to learn something from this talk because right
> now the state of the art in the C++ world is far from perfect.
>
>
> ----------------------- REVIEW 4 ---------------------
> PAPER: 3
> TITLE: Testing Battle.net (before deploying to millions of players)
> AUTHORS: Ben Deane
>
> OVERALL EVALUATION: 2 (accept)
> REVIEWER'S CONFIDENCE: 4 (high)
>
> ----------- REVIEW -----------
> Testing a large scale distributed system will be very tricky. Testing
> code for correctness, performance and scalability without having to
> deploy a full-scale environment and spin up a million clients? I'm in!
>
>
> ----------------------- REVIEW 5 ---------------------
> PAPER: 3
> TITLE: Testing Battle.net (before deploying to millions of players)
> AUTHORS: Ben Deane
>
> OVERALL EVALUATION: 0 (borderline paper) REVIEWER'S CONFIDENCE: 4
> (high)
>
> ----------- REVIEW -----------
> Even though testing is a large percentage of development costs and
> testing across network is even more difficult, the question remains
> what is necessary to modify in C++ that would make this task more
> efficient? Is there a thread running in the background to monitor
> performance or any issues that may arise during execution?
>
> If these questions can be answered, then let the presentation be given.
>
>
> ----------------------- REVIEW 6 ---------------------
> PAPER: 3
> TITLE: Testing Battle.net (before deploying to millions of players)
> AUTHORS: Ben Deane
>
> OVERALL EVALUATION: 2 (accept)
> REVIEWER'S CONFIDENCE: 3 (medium)
>
> ----------- REVIEW -----------
> Scalability adds a new dimension to the world of testing.  Given the
> author's experience at Blizzard, I believe he will provide unique
> insight into building confidence in systems that get deployed to millions of simultaneous users.
>
> Given the push towards value semantics (type erasure vs. exposed class
> hierarchies), I would like to see the author address how to make those
> things testable as well, (hopefully) without adding complexity or run
> time cost to the production codebase.
>
